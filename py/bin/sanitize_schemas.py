#!/usr/bin/env python3
#
# Copyright 2025 Google LLC
# SPDX-License-Identifier: Apache-2.0


"""Standalone convenience script used to massage the schemas.py.

The `py/packages/genkit/src/genkit/core/schemas.py` file is generated by
datamodel-codegen. However, since the tool doesn't currently provide options to
generate exactly the kind of code we need, we use this convenience script to
parse the Python source code, walk the AST, modify it to include the bits we
need and regenerate the code for eventual use within our codebase.

Transformations applied:
- We remove the model_config attribute from classes that ineherit from
  RootModel.
- We add the `populate_by_name=True` parameter to ensure serialization uses
  camelCase for attributes since the JS implementation uses camelCase and Python
  uses snake_case. The codegen pass is configured to generate snake_case for a
  Pythonic API but serialize to camelCase in order to be compatible with
  runtimes.
- We add a license header
- We add a header indicating that this file has been generated by a code generator
  pass.
- We add the ability to use forward references.
"""

import ast
import sys
from datetime import datetime
from pathlib import Path


class ModelConfigRemover(ast.NodeTransformer):
    def __init__(self) -> None:
        self.modified = False

    def is_rootmodel_class(self, node: ast.ClassDef) -> bool:
        """Check if the class inherits from RootModel."""
        for base in node.bases:
            if isinstance(base, ast.Name) and base.id == 'RootModel':
                return True
            elif isinstance(base, ast.Subscript):
                if (
                    isinstance(base.value, ast.Name)
                    and base.value.id == 'RootModel'
                ):
                    return True
        return False

    def create_model_config(
        self, extra_forbid: bool = True, populate_by_name: bool = True
    ) -> ast.Assign:
        """Create a model_config assignment with the specified options."""
        keywords = []
        if extra_forbid:
            keywords.append(
                ast.keyword(arg='extra', value=ast.Constant(value='forbid'))
            )
        if populate_by_name:
            keywords.append(
                ast.keyword(
                    arg='populate_by_name', value=ast.Constant(value=True)
                )
            )

        return ast.Assign(
            targets=[ast.Name(id='model_config')],
            value=ast.Call(
                func=ast.Name(id='ConfigDict'), args=[], keywords=keywords
            ),
        )

    def has_model_config(self, node: ast.ClassDef) -> bool:
        """Check if a class already has a model_config assignment."""
        for item in node.body:
            if isinstance(item, ast.Assign):
                targets = item.targets
                if len(targets) == 1 and isinstance(targets[0], ast.Name):
                    if targets[0].id == 'model_config':
                        return True
        return False

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:  # noqa: N802
        """Visit class definitions and handle model_config based on class type."""
        if self.is_rootmodel_class(node):
            # Filter out model_config assignments for RootModel classes
            new_body = []
            for item in node.body:
                if isinstance(item, ast.Assign):
                    targets = item.targets
                    if len(targets) == 1 and isinstance(targets[0], ast.Name):
                        if targets[0].id != 'model_config':
                            new_body.append(item)
                else:
                    new_body.append(item)

            if len(new_body) != len(node.body):
                self.modified = True

            node.body = new_body
        else:
            # For non-RootModel classes that inherit from BaseModel
            if any(
                isinstance(base, ast.Name) and base.id == 'BaseModel'
                for base in node.bases
            ):
                if not self.has_model_config(node):
                    # Add model_config with populate_by_name=True
                    node.body.insert(0, self.create_model_config())
                    self.modified = True
                else:
                    # Update existing model_config to include populate_by_name=True
                    new_body = []
                    for item in node.body:
                        if isinstance(item, ast.Assign):
                            targets = item.targets
                            if len(targets) == 1 and isinstance(
                                targets[0], ast.Name
                            ):
                                if targets[0].id == 'model_config':
                                    new_body.append(self.create_model_config())
                                    self.modified = True
                                    continue
                        new_body.append(item)
                    node.body = new_body

        return node


def add_header(content: str) -> str:
    """Add the generated header to the content."""
    header = """# Copyright {year} Google LLC
# SPDX-License-Identifier: Apache-2.0

# DO NOT EDIT: Generated by `generate_schema_types` from `genkit-schemas.json`.

from __future__ import annotations
"""
    return header.format(year=datetime.now().year) + content


def process_file(filename: str) -> None:
    """Process a Python file to remove model_config from RootModel classes
    and add the generated header."""
    path = Path(filename)
    if not path.is_file():
        raise FileNotFoundError(f'{filename} does not exist or is not a file')

    # Read the file
    content = path.read_text(encoding='utf-8')

    # Then process the AST
    tree = ast.parse(content)
    transformer = ModelConfigRemover()
    modified_tree = transformer.visit(tree)

    if transformer.modified:
        # Write back the modified content.
        ast.fix_missing_locations(modified_tree)
        modified_source = ast.unparse(modified_tree)
        src = add_header(modified_source)
        path.write_text(src, encoding='utf-8')
        print(
            f'Modified {filename}: Removed model_config from RootModel classes'
        )
    else:
        # Even if no AST modifications, still write back to add the header.
        path.write_text(add_header(content), encoding='utf-8')
        print(f'Added header to {filename}')


def main() -> None:
    if len(sys.argv) != 2:
        print('Usage: python script.py <filename>')
        sys.exit(1)

    filename = sys.argv[1]
    try:
        process_file(filename)
    except Exception as e:
        print(f'Error processing {filename}: {str(e)}')
        sys.exit(1)


if __name__ == '__main__':
    main()
