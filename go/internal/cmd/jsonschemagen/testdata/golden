// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was generated by jsonschemagen. DO NOT EDIT.

package test

// A Candidate is a single generated result.
//
// Something after a blank line.
type Candidate struct {
	Custom        any          `json:"custom,omitempty"`
	FinishMessage string       `json:"finishMessage,omitempty"`
	FinishReason  FinishReason `json:"finishReason,omitempty"`
	// Position of candidate in list.
	Index   int              `json:"index,omitempty"`
	Message *Message         `json:"message,omitempty"`
	Usage   *GenerationUsage `json:"usage,omitempty"`
}

type FinishReason string

const (
	FinishReasonStop    FinishReason = "stop"
	FinishReasonLength  FinishReason = "length"
	FinishReasonBlocked FinishReason = "blocked"
	FinishReasonOther   FinishReason = "other"
	FinishReasonUnknown FinishReason = "unknown"
)

type DocumentData struct {
	Content  []any          `json:"content,omitempty"`
	Metadata map[string]any `json:"metadata,omitempty"`
}

type FlowError struct {
	Error      string `json:"error,omitempty"`
	Stacktrace string `json:"stacktrace,omitempty"`
}

type FlowInvokeEnvelopeMessage struct {
	Resume       *FlowInvokeEnvelopeMessage_resume       `json:"resume,omitempty"`
	Retry        *FlowInvokeEnvelopeMessage_retry        `json:"retry,omitempty"`
	RunScheduled *FlowInvokeEnvelopeMessage_runScheduled `json:"runScheduled,omitempty"`
	Schedule     *FlowInvokeEnvelopeMessage_schedule     `json:"schedule,omitempty"`
	Start        *FlowInvokeEnvelopeMessage_start        `json:"start,omitempty"`
	State        *FlowInvokeEnvelopeMessage_state        `json:"state,omitempty"`
}

type FlowInvokeEnvelopeMessage_resume struct {
	FlowID  string `json:"flowId,omitempty"`
	Payload any    `json:"payload,omitempty"`
}

type FlowInvokeEnvelopeMessage_retry struct {
	FlowID string `json:"flowId,omitempty"`
}

type FlowInvokeEnvelopeMessage_runScheduled struct {
	FlowID string `json:"flowId,omitempty"`
}

type FlowInvokeEnvelopeMessage_schedule struct {
	Delay float64 `json:"delay,omitempty"`
	Input any     `json:"input,omitempty"`
}

type FlowInvokeEnvelopeMessage_start struct {
	Input  any               `json:"input,omitempty"`
	Labels map[string]string `json:"labels,omitempty"`
}

type FlowInvokeEnvelopeMessage_state struct {
	FlowID string `json:"flowId,omitempty"`
}

type FlowResponse struct {
	Response any `json:"response,omitempty"`
}

type FlowState struct {
	BlockedOnStep   any                   `json:"blockedOnStep,omitempty"`
	Cache           map[string]any        `json:"cache,omitempty"`
	EventsTriggered map[string]any        `json:"eventsTriggered,omitempty"`
	Executions      []*FlowStateExecution `json:"executions,omitempty"`
	FlowID          string                `json:"flowId,omitempty"`
	Input           any                   `json:"input,omitempty"`
	Name            string                `json:"name,omitempty"`
	Operation       *Operation            `json:"operation,omitempty"`
	StartTime       float64               `json:"startTime,omitempty"`
	TraceContext    string                `json:"traceContext,omitempty"`
}

type FlowStateExecution struct {
	EndTime   float64  `json:"endTime,omitempty"`
	StartTime float64  `json:"startTime,omitempty"`
	TraceIDs  []string `json:"traceIds,omitempty"`
}

type GenerationConfig struct {
	Custom          map[string]any `json:"custom,omitempty"`
	MaxOutputTokens float64        `json:"maxOutputTokens,omitempty"`
	StopSequences   []string       `json:"stopSequences,omitempty"`
	Temperature     float64        `json:"temperature,omitempty"`
	TopK            float64        `json:"topK,omitempty"`
	TopP            float64        `json:"topP,omitempty"`
}

type GenerationRequest struct {
	Candidates float64                   `json:"candidates,omitempty"`
	Config     *GenerationConfig         `json:"config,omitempty"`
	Messages   []*Message                `json:"messages,omitempty"`
	Output     *GenerationRequest_output `json:"output,omitempty"`
	Tools      []*ToolDefinition         `json:"tools,omitempty"`
}

type GenerationRequest_output struct {
	Format GenerationRequest_output_format `json:"format,omitempty"`
	Schema map[string]any                  `json:"schema,omitempty"`
}

type GenerationRequest_output_format string

const (
	GenerationRequest_output_formatJson GenerationRequest_output_format = "json"
	GenerationRequest_output_formatText GenerationRequest_output_format = "text"
)

type GenerationResponse struct {
	Candidates []*Candidate     `json:"candidates,omitempty"`
	Custom     any              `json:"custom,omitempty"`
	Usage      *GenerationUsage `json:"usage,omitempty"`
}

type GenerationUsage struct {
	Custom       map[string]float64 `json:"custom,omitempty"`
	InputTokens  float64            `json:"inputTokens,omitempty"`
	OutputTokens float64            `json:"outputTokens,omitempty"`
	TotalTokens  float64            `json:"totalTokens,omitempty"`
}

type InstrumentationLibrary struct {
	Name      string `json:"name,omitempty"`
	SchemaUrl string `json:"schemaUrl,omitempty"`
	Version   string `json:"version,omitempty"`
}

type Link struct {
	Attributes             map[string]any `json:"attributes,omitempty"`
	Context                *SpanContext   `json:"context,omitempty"`
	DroppedAttributesCount float64        `json:"droppedAttributesCount,omitempty"`
}

type MediaPart struct {
	Media *MediaPart_media `json:"media,omitempty"`
}

type MediaPart_media struct {
	ContentType string `json:"contentType,omitempty"`
	Url         string `json:"url,omitempty"`
}

type Message struct {
	Content []*Part `json:"content,omitempty"`
	Role    Role    `json:"role,omitempty"`
}

type Operation struct {
	BlockedOnStep *Operation_blockedOnStep `json:"blockedOnStep,omitempty"`
	// If the value is false, it means the operation is still in progress. If true, the operation is completed, and either error or response is available.
	Done bool `json:"done,omitempty"`
	// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time.
	Metadata any `json:"metadata,omitempty"`
	// server-assigned name, which is only unique within the same service that originally returns it.
	Name   string      `json:"name,omitempty"`
	Result *FlowResult `json:"result,omitempty"`
}

type Operation_blockedOnStep struct {
	Name   string `json:"name,omitempty"`
	Schema string `json:"schema,omitempty"`
}

type Role string

const (
	RoleSystem Role = "system"
	RoleUser   Role = "user"
	RoleModel  Role = "model"
	RoleTool   Role = "tool"
)

type SpanContext struct {
	IsRemote   bool    `json:"isRemote,omitempty"`
	SpanID     string  `json:"spanId,omitempty"`
	TraceFlags float64 `json:"traceFlags,omitempty"`
	TraceID    string  `json:"traceId,omitempty"`
}

type SpanData struct {
	Attributes              map[string]any                    `json:"attributes,omitempty"`
	DisplayName             string                            `json:"displayName,omitempty"`
	EndTime                 float64                           `json:"endTime,omitempty"`
	InstrumentationLibrary  *InstrumentationLibrary           `json:"instrumentationLibrary,omitempty"`
	Links                   []*Link                           `json:"links,omitempty"`
	ParentSpanID            string                            `json:"parentSpanId,omitempty"`
	SameProcessAsParentSpan *SpanData_sameProcessAsParentSpan `json:"sameProcessAsParentSpan,omitempty"`
	SpanID                  string                            `json:"spanId,omitempty"`
	SpanKind                string                            `json:"spanKind,omitempty"`
	StartTime               float64                           `json:"startTime,omitempty"`
	Status                  *SpanStatus                       `json:"status,omitempty"`
	TimeEvents              *SpanData_timeEvents              `json:"timeEvents,omitempty"`
	TraceID                 string                            `json:"traceId,omitempty"`
}

type SpanData_sameProcessAsParentSpan struct {
	Value bool `json:"value,omitempty"`
}

type SpanData_timeEvents struct {
	TimeEvent []*TimeEvent `json:"timeEvent,omitempty"`
}

type SpanMetadata struct {
	Input    any                `json:"input,omitempty"`
	IsRoot   bool               `json:"isRoot,omitempty"`
	Metadata map[string]string  `json:"metadata,omitempty"`
	Name     string             `json:"name,omitempty"`
	Output   any                `json:"output,omitempty"`
	State    SpanMetadata_state `json:"state,omitempty"`
}

type SpanMetadata_state string

const (
	SpanMetadata_stateSuccess SpanMetadata_state = "success"
	SpanMetadata_stateError   SpanMetadata_state = "error"
)

type SpanStatus struct {
	Code    float64 `json:"code,omitempty"`
	Message string  `json:"message,omitempty"`
}

type TextPart struct {
	Text string `json:"text,omitempty"`
}

type TimeEvent struct {
	Annotation *TimeEvent_annotation `json:"annotation,omitempty"`
	Time       float64               `json:"time,omitempty"`
}

type TimeEvent_annotation struct {
	Attributes  map[string]any `json:"attributes,omitempty"`
	Description string         `json:"description,omitempty"`
}

type ToolDefinition struct {
	// Valid JSON Schema representing the input of the tool.
	InputSchema map[string]any `json:"inputSchema,omitempty"`
	Name        string         `json:"name,omitempty"`
	// Valid JSON Schema describing the output of the tool.
	OutputSchema map[string]any `json:"outputSchema,omitempty"`
}

type ToolRequestPart struct {
	ToolRequest *ToolRequestPart_toolRequest `json:"toolRequest,omitempty"`
}

type ToolRequestPart_toolRequest struct {
	Input any    `json:"input,omitempty"`
	Name  string `json:"name,omitempty"`
	Ref   string `json:"ref,omitempty"`
}

type ToolResponsePart struct {
	ToolResponse *ToolResponsePart_toolResponse `json:"toolResponse,omitempty"`
}

type ToolResponsePart_toolResponse struct {
	Name   string `json:"name,omitempty"`
	Output any    `json:"output,omitempty"`
	Ref    string `json:"ref,omitempty"`
}

type TraceData struct {
	DisplayName string               `json:"displayName,omitempty"`
	EndTime     float64              `json:"endTime,omitempty"`
	Spans       map[string]*SpanData `json:"spans,omitempty"`
	StartTime   float64              `json:"startTime,omitempty"`
}
